# üìã Reglas Globales de Trabajo - Claude Assistant & NestJS Backend

**Lea siempre este archivo al inicio de cada conversaci√≥n para mantener consistencia en comunicaci√≥n, arquitectura y metodolog√≠a de trabajo.**

## üéØ **Filosof√≠a de Trabajo**

- **Tono**: Profesional pero accesible, directo y colaborativo
- **Idioma**: C√≥digo en ingl√©s, mensajes de usuario en espa√±ol
- **Enfoque**: Soluciones pr√°cticas inmediatas con mejores pr√°cticas
- **Gesti√≥n de dependencias**: Usar `yarn` exclusivamente

## üèóÔ∏è Arquitectura y Estructura Modular

### Estructura de Directorios Backend
```
src/
‚îú‚îÄ‚îÄ app.module.ts                 # M√≥dulo ra√≠z de la aplicaci√≥n
‚îú‚îÄ‚îÄ main.ts                      # Punto de entrada de la aplicaci√≥n
‚îÇ
‚îú‚îÄ‚îÄ common/                      # Recursos compartidos globales
‚îÇ   ‚îú‚îÄ‚îÄ decorators/              # Decoradores personalizados
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ roles.decorator.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ public.decorator.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ guards/                  # Guards de autenticaci√≥n y autorizaci√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.guard.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ roles.guard.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jwt-auth.guard.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ filters/                 # Filtros globales
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ http-exception.filter.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ strategies/              # Estrategias de autenticaci√≥n
‚îÇ       ‚îú‚îÄ‚îÄ jwt.strategy.ts
‚îÇ       ‚îî‚îÄ‚îÄ index.ts
‚îÇ
‚îú‚îÄ‚îÄ modules/                     # M√≥dulos de funcionalidad
‚îÇ   ‚îú‚îÄ‚îÄ auth/                    # M√≥dulo de autenticaci√≥n
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.module.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/            # Entidades espec√≠ficas del m√≥dulo
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.entity.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/                 # DTOs con class-validator (validaci√≥n entrada)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ register.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/               # Types/Interfaces (manejo interno)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth-response.type.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth-payload.type.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ users/                   # M√≥dulo de usuarios
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.module.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.controller.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.entity.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dto/                 # DTOs con class-validator (validaci√≥n entrada)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-user.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ update-user.dto.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/               # Types/Interfaces (manejo interno)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-response.type.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-payload.type.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ [feature-module]/        # Otros m√≥dulos de funcionalidad
‚îÇ       ‚îú‚îÄ‚îÄ [feature].module.ts
‚îÇ       ‚îú‚îÄ‚îÄ [feature].controller.ts
‚îÇ       ‚îú‚îÄ‚îÄ [feature].service.ts
‚îÇ       ‚îú‚îÄ‚îÄ entities/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ [feature].entity.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ       ‚îú‚îÄ‚îÄ dto/                 # DTOs con class-validator (validaci√≥n entrada)
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ create-[feature].dto.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update-[feature].dto.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ       ‚îú‚îÄ‚îÄ types/               # Types/Interfaces (manejo interno)
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ [feature]-response.type.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ [feature]-payload.type.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ
‚îî‚îÄ‚îÄ shared/                      # Servicios compartidos
‚îÇ   ‚îú‚îÄ‚îÄ database/                # Servicio de base de datos
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.module.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ migrations/          # Migraciones de TypeORM
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 001-initial-schema.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îú‚îÄ‚îÄ cache/                   # Servicio de cach√©
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache.module.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ email/                   # Servicio de email
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email.module.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ email.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ storage/                 # Servicio de almacenamiento
‚îÇ       ‚îú‚îÄ‚îÄ storage.module.ts
‚îÇ       ‚îî‚îÄ‚îÄ storage.service.ts
```

### Reglas de Modularidad

1. **L√≠mite de l√≠neas**: Nunca cree archivos de m√°s de 300 l√≠neas. Si se acerca a este l√≠mite, refactorice dividiendo en servicios, utilidades m√°s peque√±as.

2. **Separaci√≥n de responsabilidades**: Cada m√≥dulo debe tener una responsabilidad √∫nica y bien definida.

3. **Dependencias**: Los m√≥dulos solo pueden depender de m√≥dulos de nivel inferior o del mismo nivel.

4. **Inyecci√≥n de dependencias**: Use siempre inyecci√≥n de dependencias de NestJS, evite instanciaci√≥n manual.

5. **Entidades por m√≥dulo**: Cada m√≥dulo debe contener sus propias entidades espec√≠ficas.

6. **DTOs vs Types**: Use DTOs con class-validator para validaci√≥n de entrada. Use Types/Interfaces para tipado interno, respuestas y manejo de datos.

7. **Convenciones de idioma**:
   - **C√≥digo**: Variables, funciones, clases ‚Üí INGL√âS
   - **Mensajes de usuario**: Errores, √©xitos, validaciones ‚Üí ESPA√ëOL
   - **Comentarios**: Explicaciones de l√≥gica ‚Üí ESPA√ëOL
   - **Swagger**: Descriptions en espa√±ol, examples en ingl√©s

## üìù DTOs vs Types - Gu√≠a de Uso

### Cu√°ndo usar DTOs:
- **Validaci√≥n de entrada**: Datos que vienen del cliente (request body, query params)
- **Transformaci√≥n de datos**: Cuando necesitas modificar o limpiar datos
- **Documentaci√≥n**: Para Swagger/OpenAPI documentation
- **Seguridad**: Para sanitizaci√≥n y validaci√≥n estricta

### Cu√°ndo usar Types/Interfaces:
- **Respuestas de API**: OBLIGATORIO usar patr√≥n `{ status, message, data }`
- **Tipado interno**: Para variables, par√°metros de funciones internas
- **Contratos de servicios**: Interfaces entre servicios
- **Configuraci√≥n**: Para objetos de configuraci√≥n
- **Payloads internos**: Datos transformados para uso interno
- **Mapeo de datos**: Transformaciones entre entidades y respuestas

### ‚ö° **PATR√ìN OBLIGATORIO de Respuestas API**:
```typescript
// ‚úÖ SIEMPRE usar esta estructura para respuestas
export type EntityCreatedResponse = {
  status: 201;                    // C√≥digo HTTP espec√≠fico
  message: string;                // Mensaje en ESPA√ëOL
  data: EntityData;               // Datos de la entidad
};

export type EntityResponse = {
  status: number;                 // C√≥digo HTTP
  message: string;                // Mensaje en ESPA√ëOL
  data?: EntityData | EntityData[]; // Datos opcionales
};

// ‚úÖ Separar los datos de la entidad
export type EntityData = {
  id: string;
  // ... campos de la entidad
  createdAt: string;             // SIEMPRE como string ISO
  updatedAt: string;             // SIEMPRE como string ISO
};
```

### Ejemplos pr√°cticos:

```typescript
// ‚úÖ DTO para validaci√≥n de entrada (carpeta dto/)
export class CreateUserDto {
  @ApiProperty({
    example: 'user@example.com',
    description: 'Email √∫nico del usuario'
  })
  @IsEmail({}, { message: 'El email debe ser v√°lido' })
  @IsNotEmpty({ message: 'El email es requerido' })
  email: string;

  @ApiProperty({
    example: 'SecurePass123!',
    description: 'Contrase√±a del usuario (m√≠nimo 8 caracteres)'
  })
  @IsString({ message: 'La contrase√±a debe ser una cadena de texto' })
  @MinLength(8, { message: 'La contrase√±a debe tener al menos 8 caracteres' })
  password: string;
}

// ‚úÖ Type para respuesta de API (carpeta types/) - PATR√ìN OBLIGATORIO
export type UserCreatedResponse = {
  status: number;
  message: string;
  data: UserData;
};

export type UserResponse = {
  status: number;
  message: string;
  data?: UserData | UserData[];
};

export type UserData = {
  id: string;
  email: string;
  role: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
};

```

## üîê Seguridad y Autenticaci√≥n

### Reglas de Seguridad Prioritarias

1. **Validaci√≥n de entrada**:
   - Use DTOs con class-validator para todas las entradas
   - Implemente sanitizaci√≥n de datos
   - Valide tipos, formatos y rangos
   - Use DTOs en lugar de pipes para validaci√≥n

2. **Autorizaci√≥n**:
   - Implemente guards basados en roles
   - Use decoradores para control de acceso granular
   - Valide permisos a nivel de recurso
   - Implemente JWT con refresh tokens

3. **Protecci√≥n de datos sensibles**:
   - Nunca loguee contrase√±as o tokens
   - Use hashing para contrase√±as (bcrypt con salt rounds >= 12)
   - Implemente rate limiting
   - Use prepared statements para prevenir SQL injection
   - Encripte datos sensibles en base de datos

### Patrones de Seguridad

```typescript
// Decorador de roles con guards
@Roles('admin', 'user')
@UseGuards(BaseAuthGuard, RolesGuard)
@Post('protected-route')
async protectedRoute() {}
```

## üöÄ Rendimiento y Escalabilidad

### Reglas de Rendimiento

1. **Cach√© inteligente**:
   - Implemente cach√© para consultas frecuentes
   - Use TTL apropiados
   - Invalide cach√© cuando sea necesario
   - Use Redis para cach√© distribuido

2. **Paginaci√≥n**:
   - Implemente paginaci√≥n en todas las listas
   - Use cursor-based pagination para grandes datasets
   - L√≠mite m√°ximo de 100 elementos por p√°gina
   - Use √≠ndices de base de datos para consultas eficientes

3. **Optimizaci√≥n de base de datos**:
   - Use √≠ndices apropiados en columnas frecuentemente consultadas
   - Implemente lazy loading para relaciones
   - Use query builder para consultas complejas
   - Monitoree slow queries

4. **Compresi√≥n y serializaci√≥n**:
   - Use compresi√≥n gzip
   - Serialice solo datos necesarios
   - Implemente transform interceptors

### Patrones de Escalabilidad

```typescript
// Paginaci√≥n est√°ndar
export class PaginationDto {
  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsInt()
  @Min(1)
  @Max(100)
  limit?: number = 10;
}

// Cach√© con Redis
@Cacheable('users', 300) // 5 minutos
async findUsers(): Promise<User[]> {
  return this.userRepository.find();
}

// Query optimizada con √≠ndices
async findUsersByRole(role: string, pagination: PaginationDto): Promise<[User[], number]> {
  return this.userRepository.findAndCount({
    where: { role },
    skip: (pagination.page - 1) * pagination.limit,
    take: pagination.limit,
    order: { createdAt: 'DESC' }
  });
}

// Transacci√≥n de base de datos
async createUserWithProfile(userData: CreateUserDto, profileData: CreateProfileDto): Promise<User> {
  return this.userRepository.manager.transaction(async manager => {
    const user = manager.create(User, userData);
    const savedUser = await manager.save(user);

    const profile = manager.create(Profile, { ...profileData, userId: savedUser.id });
    await manager.save(profile);

    return savedUser;
  });
}
```

## üß™ Testing y Documentaci√≥n

### Estrategia de Testing

1. **Cobertura m√≠nima**: 80% para servicios cr√≠ticos, 60% para el resto
2. **Tipos de tests**:
   - Unit tests para servicios y utilidades
   - E2E tests para flujos completos

3. **Mocking**:
   - Mock servicios externos
   - Use test doubles para base de datos
   - A√≠sle dependencias
   - Use test database para integration tests

### Patrones de Testing

```typescript
// Test de servicio
describe('UserService', () => {
  let service: UserService;
  let repository: Repository<User>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UserService,
        {
          provide: getRepositoryToken(User),
          useValue: mockRepository,
        },
      ],
    }).compile();

    service = module.get<UserService>(UserService);
    repository = module.get<Repository<User>>(getRepositoryToken(User));
  });

  it('should create a user', async () => {
    const userData = { email: 'test@example.com', password: 'password123' };
    const expectedUser = { id: 1, ...userData };

    jest.spyOn(repository, 'save').mockResolvedValue(expectedUser);

    const result = await service.create(userData);
    expect(result).toEqual(expectedUser);
  });
});
```

## üìö Documentaci√≥n y Mantenibilidad

### Reglas de Documentaci√≥n

1. **Swagger/OpenAPI**:
   - Documente todos los endpoints
   - Use decoradores de Swagger
   - Mantenga ejemplos actualizados

2. **Comentarios de c√≥digo**:
   - Documente l√≥gica compleja
   - Explique decisiones de negocio
   - Mantenga README actualizado


### Patrones de Documentaci√≥n

```typescript
@ApiTags('Usuarios')
@Controller('users')
@ApiBearerAuth('JWT-auth')
@UseGuards(BaseAuthGuard, RolesGuard)
@Roles('admin')
export class UsersController {
  private readonly logger = new Logger(UsersController.name);

  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiOperation({
    summary: 'Crear nuevo usuario',
    description: 'Crea un usuario con validaciones completas y rol asignado'
  })
  @ApiBody({
    type: CreateUserDto,
    examples: {
      admin: {
        summary: 'Usuario administrador',
        value: {
          email: 'admin@example.com',
          password: 'SecurePass123!',
          role: 'admin'
        }
      }
    }
  })
  @ApiResponse({
    status: 201,
    description: 'Usuario creado exitosamente',
    schema: {
      example: {
        status: 201,
        message: 'Usuario creado exitosamente',
        data: {
          id: 'uuid-here',
          email: 'admin@example.com',
          role: 'admin',
          isActive: true,
          createdAt: '2025-10-02T12:00:00.000Z'
        }
      }
    }
  })
  @ApiResponse({
    status: 400,
    description: 'Datos de entrada inv√°lidos',
    schema: {
      example: {
        statusCode: 400,
        message: ['El email debe ser v√°lido', 'La contrase√±a es requerida'],
        error: 'Bad Request'
      }
    }
  })
  @ApiResponse({ status: 409, description: 'Email ya registrado' })
  async create(@Body() createUserDto: CreateUserDto): Promise<UserCreatedResponse> {
    return this.usersService.create(createUserDto);
  }
}
```

## üóÑÔ∏è TypeORM y Base de Datos

### Configuraci√≥n de TypeORM

1. **Configuraci√≥n de conexi√≥n**:
   - Use variables de entorno para configuraci√≥n
   - Implemente m√∫ltiples entornos (dev, test, prod)
   - Configure pool de conexiones apropiado
   - **IMPORTANTE**: Habilite la extensi√≥n `uuid-ossp` en PostgreSQL para usar UUIDs

2. **Entidades**:
   - Use decoradores apropiados para columnas
   - Implemente relaciones correctamente
   - Use √≠ndices para optimizaci√≥n
   - **SIEMPRE incluir**: `id`, `createdAt`, `updatedAt`
   - **Nombres de columna**: usar `snake_case` en base de datos

### Patrones de TypeORM

```typescript
// Configuraci√≥n de TypeORM
@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: process.env.DB_HOST,
      port: +process.env.DB_PORT,
      username: process.env.DB_USERNAME,
      password: process.env.DB_PASSWORD,
      database: process.env.DB_NAME,
      entities: [__dirname + '/**/*.entity{.ts,.js}'],
      migrations: [__dirname + '/migrations/*{.ts,.js}'],
      synchronize: process.env.NODE_ENV === 'development',
      logging: process.env.NODE_ENV === 'development',
      ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    }),
  ],
})
export class DatabaseModule {}

// ‚úÖ Entidad siguiendo PATR√ìN OBLIGATORIO
@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ type: 'varchar', length: 255, unique: true })
  email: string;

  @Column({ type: 'varchar', length: 255, select: false, name: 'password_hash' })
  password: string;

  @Column({ type: 'enum', enum: ['admin', 'user'], default: 'user' })
  role: string;

  @Column({ type: 'boolean', default: true, name: 'is_active' })
  isActive: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt: Date;

  // Relaciones
  @OneToMany(() => Post, post => post.author)
  posts: Post[];
}

// Repositorio personalizado
@Injectable()
export class UserRepository extends Repository<User> {
  async findActiveUsers(): Promise<User[]> {
    return this.find({ where: { isActive: true } });
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.findOne({ where: { email } });
  }
}
```

## üîß Convenciones de C√≥digo

### Nomenclatura

- **Archivos**: kebab-case (user.service.ts)
- **Clases**: PascalCase (UserService)
- **M√©todos/variables**: camelCase (createUser)
- **Constantes**: UPPER_SNAKE_CASE (API_BASE_URL)
- **Types**: PascalCase con prefijo I (IUserService) o sin prefijo (UserService)
- **Entidades**: PascalCase (User, Post)
- **Repositorios**: PascalCase + Repository (UserRepository)

### Estructura de Archivos

```typescript
// Estructura est√°ndar de un m√≥dulo
@Module({
  imports: [
    /* m√≥dulos importados */
  ],
  controllers: [FeatureController],
  providers: [FeatureService /* otros providers */],
  exports: [FeatureService],
})
export class FeatureModule {}

@Controller('feature')
export class FeatureController {
  constructor(private readonly featureService: FeatureService) {}
}

@Injectable()
export class FeatureService {
  // Implementaci√≥n del servicio
}
```

## ü§ñ Reglas de Comportamiento de Claude

### üìù **Comunicaci√≥n y Respuestas**
1. **Tono profesional pero accesible** - Directo, colaborativo y proactivo
2. **Estructura clara**: Respuesta directa ‚Üí Implementaci√≥n ‚Üí Consideraciones ‚Üí Pr√≥ximos pasos
3. **Usar emojis categorizadores**: üîß implementaci√≥n, üìã lista, ‚ö° r√°pido, üöÄ mejora
4. **Ejemplos funcionales**: C√≥digo que se pueda copiar y usar directamente
5. **Anticipar necesidades**: Ofrecer alternativas y mejoras sin ser solicitado

### üîß **Implementaci√≥n T√©cnica**
6. **Nunca asuma contexto faltante** - Preguntar si no est√° seguro
7. **Solo paquetes yarn verificados** - No alucinar librer√≠as
8. **Confirmar rutas y nombres** antes de referenciarlos
9. **Nunca eliminar c√≥digo existente** sin confirmaci√≥n expl√≠cita
10. **Siempre proporcionar tipos TypeScript** para nuevas funciones
11. **Verificar compatibilidad** de dependencias con NestJS y TypeORM

### üõ°Ô∏è **Seguridad y Calidad**
12. **Implementar manejo de errores** en todas las operaciones
13. **Usar inyecci√≥n de dependencias** en lugar de instanciaci√≥n manual
14. **Validar todas las entradas** con DTOs y class-validator
15. **Separar DTOs de Types** - DTOs para validaci√≥n, Types para manejo interno
16. **Implementar logging** para operaciones cr√≠ticas
17. **Usar transacciones** para operaciones que afecten m√∫ltiples entidades

### üìä **Base de Datos y Performance**
18. **Siempre usar repositorios** en lugar de acceso directo a DataSource
19. **Implementar soft deletes** cuando sea apropiado
20. **Usar √≠ndices de base de datos** para optimizar consultas frecuentes
21. **Implementar paginaci√≥n** en listados por defecto

### üåç **Convenciones de Idioma**
22. **C√≥digo en INGL√âS**: Variables, funciones, clases, constantes
23. **Mensajes en ESPA√ëOL**: Errores, validaciones, respuestas al usuario
24. **Comentarios en ESPA√ëOL**: Explicaciones de l√≥gica y documentaci√≥n
25. **Swagger**: Descriptions en espa√±ol, examples en ingl√©s

### üìä **Patr√≥n de Respuestas OBLIGATORIO**
26. **SIEMPRE usar estructura**: `{ status, message, data }`
27. **Status**: C√≥digo HTTP num√©rico exacto (200, 201, 400, etc.)
28. **Message**: Mensaje descriptivo en ESPA√ëOL
29. **Data**: Datos de la entidad o array, OPCIONAL en errores
30. **Fechas**: SIEMPRE como string ISO, nunca como Date en responses

## üéØ Prioridades de Implementaci√≥n

1. **Seguridad** (Cr√≠tico) - Autenticaci√≥n, autorizaci√≥n, validaci√≥n
2. **Base de datos** (Cr√≠tico) - Configuraci√≥n TypeORM, entidades, migraciones
3. **Manejo de errores** (Alto) - Filtros, excepciones, logging
4. **Validaci√≥n** (Alto) - DTOs, class-validator, sanitizaci√≥n
5. **Rendimiento** (Medio) - Cach√©, paginaci√≥n, optimizaci√≥n de queries
6. **Testing** (Medio) - Cobertura, mocking, E2E
7. **Documentaci√≥n** (Bajo) - Swagger, comentarios, README

## üîÑ Patrones de Migraci√≥n y Evoluci√≥n

1. **Versionado de API**: Use `/api/v1/`, `/api/v2/` para versiones
2. **Feature flags**: Implemente para rollouts graduales
3. **Database migrations**: Use TypeORM migrations para cambios de esquema
4. **Backward compatibility**: Mantenga compatibilidad por al menos 2 versiones
5. **Deprecation warnings**: Notifique cambios futuros con anticipaci√≥n

### üîß **Servicios - Patr√≥n de Respuestas OBLIGATORIO**

```typescript
// ‚úÖ SIEMPRE implementar este patr√≥n en servicios
@Injectable()
export class UsersService {
  private readonly logger = new Logger(UsersService.name);

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    private readonly dataSource: DataSource,
  ) {}

  async create(createUserDto: CreateUserDto): Promise<UserCreatedResponse> {
    // L√≥gica de creaci√≥n...
    const user = await this.userRepository.save(newUser);

    // ‚úÖ SIEMPRE retornar con este patr√≥n
    return {
      status: 201,
      message: 'Usuario creado exitosamente',
      data: user
    };
  }

  async findAll(): Promise<UserResponse> {
    const users = await this.userRepository.find();

    return {
      status: 200,
      message: 'Usuarios obtenidos exitosamente',
      data: users
    };
  }

  async remove(id: string): Promise<UserResponse> {
    await this.userRepository.delete(id);

    return {
      status: 200,
      message: 'Usuario eliminado exitosamente',
      // ‚ö° Sin data en operaciones de eliminaci√≥n
    };
  }
}
```

### üìä **Reglas de Mapeo de Datos**

1. **Fechas**: SIEMPRE convertir `Date` a `string` con `.toISOString()`
2. **IDs**: SIEMPRE incluir en responses
3. **Campos sensibles**: NUNCA incluir passwords, tokens en responses
4. **Status codes**: Usar c√≥digos HTTP espec√≠ficos (201 para creaci√≥n, 200 para √©xito)
5. **Messages**: SIEMPRE en espa√±ol, descriptivos y consistentes

### Patrones de Migraci√≥n TypeORM

```typescript
// ‚úÖ Migraci√≥n siguiendo convenciones del proyecto
export class CreateUsersTable1234567890123 implements MigrationInterface {
  name = 'CreateUsersTable1234567890123'

  public async up(queryRunner: QueryRunner): Promise<void> {
    // ‚ö° OBLIGATORIO: Habilitar extensi√≥n UUID
    await queryRunner.query('CREATE EXTENSION IF NOT EXISTS "uuid-ossp";');

    await queryRunner.createTable(
      new Table({
        name: 'users',
        columns: [
          {
            name: 'id',
            type: 'uuid',
            isPrimary: true,
            generationStrategy: 'uuid',
            default: 'uuid_generate_v4()',
          },
          {
            name: 'email',
            type: 'varchar',
            length: '255',
            isUnique: true,
            isNullable: false,
          },
          {
            name: 'password_hash',        // ‚ö° snake_case en BD
            type: 'varchar',
            length: '255',
            isNullable: false,
          },
          {
            name: 'role',
            type: 'enum',
            enum: ['admin', 'user'],
            default: "'user'",
          },
          {
            name: 'is_active',           // ‚ö° snake_case en BD
            type: 'boolean',
            default: true,
          },
          {
            name: 'created_at',          // ‚ö° OBLIGATORIO
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
          },
          {
            name: 'updated_at',          // ‚ö° OBLIGATORIO
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            onUpdate: 'CURRENT_TIMESTAMP',
          },
        ],
      }),
      true,
    );

    // ‚ö° Crear √≠ndices para performance
    await queryRunner.createIndex('users', new Index('IDX_USER_EMAIL', ['email']));
    await queryRunner.createIndex('users', new Index('IDX_USER_ROLE', ['role']));
    await queryRunner.createIndex('users', new Index('IDX_USER_ACTIVE', ['is_active']));
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable('users');
  }
}
```

## üìã **Checklist de Aplicaci√≥n**

Antes de cada respuesta, verificar:

- [ ] ¬øEl tono es profesional pero accesible?
- [ ] ¬øLa estructura es clara y f√°cil de seguir?
- [ ] ¬øEl nivel de detalle es apropiado para la pregunta?
- [ ] ¬øInclu√≠ c√≥digo funcional cuando es relevante?
- [ ] ¬øLos mensajes de error est√°n en espa√±ol?
- [ ] ¬øLas variables y funciones est√°n en ingl√©s?
- [ ] ¬øUs√© el patr√≥n `{ status, message, data }` en responses?
- [ ] ¬øLas fechas est√°n como string ISO en responses?
- [ ] ¬øLa respuesta es inmediatamente accionable?
- [ ] ¬øAnticip√© posibles preguntas de seguimiento?
- [ ] ¬øSuger√≠ mejoras o pr√≥ximos pasos?
- [ ] ¬øUs√© el formato y emojis apropiados?

## üéØ **Formato de Respuesta Est√°ndar**

```markdown
## üéØ **Respuesta Directa**
[Soluci√≥n concreta al problema planteado]

## üìã **Implementaci√≥n**
[C√≥digo funcional con patr√≥n { status, message, data }]

## ‚ö° **Consideraciones Adicionales**
[Optimizaciones, alternativas, mejores pr√°cticas]

## üöÄ **Pr√≥ximos Pasos**
[Sugerencias para continuar o mejorar]
```

## üî• **REGLAS NO NEGOCIABLES**

1. **SIEMPRE** usar patr√≥n `{ status, message, data }` en responses
2. **NUNCA** retornar `Date` objects, siempre `string` ISO
3. **SIEMPRE** mensajes en espa√±ol para el usuario
4. **SIEMPRE** c√≥digo en ingl√©s (variables, funciones, clases)
5. **SIEMPRE** incluir `createdAt` y `updatedAt` en entidades
6. **SIEMPRE** usar `snake_case` para nombres de columnas en BD
7. **SIEMPRE** transacciones para operaciones cr√≠ticas
8. **SIEMPRE** validaciones con DTOs para entrada de datos

---
